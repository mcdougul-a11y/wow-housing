<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guild Housing Map</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="grid-overlay.css">
    <style>
    /* Mini-map removed */
    /* Force the map display to a fixed "render" resolution and add a recessed frame */
    /* Container keeps a 10px gap to the viewport edges and centers the map */
    /* Page container: responsive, centered, not full viewport so it can sit inside the site layout */
    .map-container {
        /* allow the map to render at its native size and let the page scroll as needed */
        display: block;
        box-sizing: border-box;
        /* margin/padding intentionally handled in external stylesheet to enable centering */
        overflow: auto; /* allow scrolling when the native map is larger than viewport */
    }
    .map-background {
        /* Render at the pixel size assigned by JS (native/reference resolution).
           JS will set explicit width/height/background-size on the element. */
        background-image: url('maps/alliance_map.jpg');
        background-repeat: no-repeat;
    background-position: center top;
    /* image itself has no rounding or frame; viewport (.map-inner) provides rounded border */
    border-radius: 0;
        /* No border or shadow on the image itself; viewport has the visible frame */
        border: none;
        box-shadow: none;
        overflow: visible;
        box-sizing: border-box;
        touch-action: none; /* pointer gestures disabled by earlier edits */
        cursor: default;
        position: relative;
        display: block;
    }
    /* Responsive inline plot grid (below the map) */
    .inline-plot-list { padding: 12px 24px; }
    .inline-plot-list h3 { text-align: center; margin: 0 0 12px 0; max-width: 1200px; margin-left: auto; margin-right: auto; }
    .inline-plot-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 12px;
        align-items: start;
        width: 100%;
        box-sizing: border-box;
        max-width: 1200px;
        margin: 0 auto;
    }
    .plot-card {
        background: rgba(20,20,20,0.6);
        border-radius: 8px;
        padding: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        color: #fff;
    }
    .plot-card-header { font-weight: 600; margin-bottom: 6px; }
    .plot-card-body { display:flex; gap:8px; }
    </style>
</head>
<body>
    <div class="map-container">
        <div class="map-inner">
            <div class="zoom-wrapper" id="zoomWrapper" style="transform-origin: 0 0;">
                <div class="map-background" id="mapBackground">
                    <!-- House plots will be dynamically positioned here -->
                </div>
            </div>
        </div>
    </div>

    <div class="legend">
        <div class="legend-title">Legend</div>
        <div class="legend-item">
            <div class="legend-color available"></div>
            <span>Available</span>
        </div>
        <div class="legend-item">
            <div class="legend-color interested"></div>
            <span>Interested</span>
        </div>
        <div style="margin-top: 10px; font-size: 10px; color: #ccc;">
            Press <strong>G</strong> to toggle grid
        </div>
        <!-- changeMapBtn removed: direct map buttons available in legend below -->
        <div style="margin-top:8px; text-align:center;">
                <div style="display:flex; gap:6px; justify-content:center; margin-top:6px;">
                <button id="chooseAllianceLegend" style="padding:6px 8px; font-size:12px;">Alliance</button>
                <button id="chooseHordeLegend" style="padding:6px 8px; font-size:12px;">Horde</button>
            </div>
            <div style="display:flex; gap:6px; justify-content:center; margin-top:8px;">
                <button id="togglePlotNumbersBtn" style="padding:6px 8px; font-size:12px;">Plot #</button>
            </div>
            <div style="display:flex; gap:6px; justify-content:center; margin-top:8px;">
                <div class="locale-flags" role="group" aria-label="Language">
                    <button id="localeBtnEn" class="locale-flag-btn" data-locale="en" title="English" aria-label="English">
                        <!-- US flag SVG (compact) -->
                        <svg class="locale-flag" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
                            <rect width="512" height="512" fill="#b22234"/>
                            <g fill="#fff">
                                <rect y="36" width="512" height="36"/>
                                <rect y="108" width="512" height="36"/>
                                <rect y="180" width="512" height="36"/>
                                <rect y="252" width="512" height="36"/>
                                <rect y="324" width="512" height="36"/>
                                <rect y="396" width="512" height="36"/>
                            </g>
                            <rect width="224" height="224" fill="#3c3b6e"/>
                            <!-- simple star grid (decorative, not full accuracy) -->
                            <g fill="#fff">
                                <!-- draw a few small stars -->
                                <circle cx="28" cy="28" r="8"/>
                                <circle cx="76" cy="28" r="8"/>
                                <circle cx="124" cy="28" r="8"/>
                                <circle cx="172" cy="28" r="8"/>
                                <circle cx="52" cy="60" r="8"/>
                                <circle cx="100" cy="60" r="8"/>
                                <circle cx="148" cy="60" r="8"/>
                            </g>
                        </svg>
                    </button>
                    <button id="localeBtnDe" class="locale-flag-btn" data-locale="de" title="Deutsch" aria-label="Deutsch">
                        <!-- German flag SVG (compact) -->
                        <svg class="locale-flag" viewBox="0 0 3 2" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
                            <rect width="3" height="2" fill="#000"/>
                            <rect y="0.66" width="3" height="0.66" fill="#dd0000"/>
                            <rect y="1.32" width="3" height="0.68" fill="#ffce00"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div style="font-size:11px; color:#ccc; margin-top:4px;">Shift+Click to remember choice</div>
            <div style="display:flex; gap:6px; justify-content:center; margin-top:8px;">
                <button id="zoomResetBtn" style="padding:6px 8px; font-size:12px;">100%</button>
            </div>
        </div>
        <!-- Edit plots button removed; inline editing available below -->
        <!-- Zoom controls removed: zoom is now handled via mouse wheel over the map -->
        <!-- on-screen pan buttons removed -->
        
        
    </div>

    <!-- Inline editable plot list shown under the map (compact grid) -->
    <div id="inlinePlotList" class="inline-plot-list" style="margin:12px 24px; color:#fff;">
        <h3 id="inlinePlotHeader" style="margin-bottom:8px; color:#fff;">Plots (Interested)</h3>
        <div id="inlinePlotGrid" class="inline-plot-grid" style="max-width:1200px;">
            <!-- Cards will be injected here -->
        </div>
    </div>

    <!-- Hover preview container (created here for styling) -->
    <div id="plotHoverPreview">
        <img class="preview-img" src="" alt="Preview" />
        <div class="preview-meta"><div class="plot-number"></div><div class="plot-interested"></div></div>
    </div>

    <!-- Mini-map removed -->

    <script>
        // Housing data from CSV
        const housingData = {
        };

    // House plot positions loaded from external JSON file
    let plotPositions = [];
    let mapImageData = {};
    // Cached Image used for measuring the map dimensions to avoid creating a new Image on every update
    let cachedMapImage = new Image();
    let cachedMapImagePath = null;
    // Global debug toggle: set window.__housingDebug = true in console to enable verbose logs
    if (typeof window !== 'undefined' && typeof window.__housingDebug === 'undefined') window.__housingDebug = false;
    // Cached DOM lists for hot-path rendering
    let cachedPlots = [];
    let cachedIcons = [];
    let cachedDots = [];
    let cachedLabels = [];

    // Coalesced update scheduler using requestAnimationFrame
    let updateScheduled = false;
    function scheduleUpdatePlotPositions() {
        if (updateScheduled) return;
        updateScheduled = true;
        requestAnimationFrame(() => {
            updateScheduled = false;
            try { updatePlotPositions(); } catch (e) { console.warn('scheduled updatePlotPositions error', e); }
        });
    }

    // Simple debounce helper
    function debounce(fn, wait) {
        let t = null;
        return function(...args) {
            if (t) clearTimeout(t);
            t = setTimeout(() => { t = null; fn.apply(this, args); }, wait);
        };
    }
    // user-entered overrides stored per map: { '<mapFilename>': { plotNumber: name, ... }, ... }
    let housingOverridesByMap = {};
    // interested persons per plot, per map: { '<mapFilename>': { plotNumber: 'names, ...' }, ... }
    let housingInterestedByMap = {};

    // Minimal translations for visible UI (table and related labels)
    const translations = {
        en: {
            inlinePlotHeader: 'Plots (Interested)',
            plotLabel: 'Plot {num}',
            placeholderInterested: 'Interested',
            legendTitle: 'Legend',
            availableLabel: 'Available',
            interestedLabel: 'Interested',
            chooseAlliance: 'Alliance',
            chooseHorde: 'Horde',
            plotToggle: 'Plot #',
            zoomReset: '100%'
        },
        de: {
            inlinePlotHeader: 'Grundstücke (Interessenten)',
            plotLabel: 'Grundstück {num}',
            placeholderInterested: 'Interessiert',
            legendTitle: 'Legende',
            availableLabel: 'Verfügbar',
            interestedLabel: 'Interessenten',
            chooseAlliance: 'Allianz',
            chooseHorde: 'Horde',
            plotToggle: 'Grundstück Nr.',
            zoomReset: '100%'
        }
    };

    // Add interestedPrefix translations
    translations.en.interestedPrefix = 'Interested: {names}';
    translations.de.interestedPrefix = 'Interessenten: {names}';

    function applyVisibleLocale(locale) {
        try {
            if (locale) try { localStorage.setItem('locale', locale); } catch (e) {}
            // update legend and inline header/buttons
            const inlineHeader = document.getElementById('inlinePlotHeader');
            if (inlineHeader) inlineHeader.textContent = getText('inlinePlotHeader');
            const legendTitle = document.querySelector('.legend .legend-title');
            if (legendTitle) legendTitle.textContent = getText('legendTitle') || legendTitle.textContent;
            const legendSpans = document.querySelectorAll('.legend .legend-item > span');
            if (legendSpans && legendSpans.length >= 2) {
                legendSpans[0].textContent = getText('availableLabel') || legendSpans[0].textContent;
                legendSpans[1].textContent = getText('interestedLabel') || legendSpans[1].textContent;
            }
            const chooseAllianceLegendBtn = document.getElementById('chooseAllianceLegend');
            if (chooseAllianceLegendBtn) chooseAllianceLegendBtn.textContent = getText('chooseAlliance') || chooseAllianceLegendBtn.textContent;
            const chooseHordeLegendBtn = document.getElementById('chooseHordeLegend');
            if (chooseHordeLegendBtn) chooseHordeLegendBtn.textContent = getText('chooseHorde') || chooseHordeLegendBtn.textContent;
            const toggleBtn = document.getElementById('togglePlotNumbersBtn');
            if (toggleBtn) toggleBtn.textContent = getText('plotToggle') || toggleBtn.textContent;
            const zoomBtn = document.getElementById('zoomResetBtn');
            if (zoomBtn) zoomBtn.textContent = getText('zoomReset') || zoomBtn.textContent;
            // Update existing inline plot list
            buildInlinePlotList();
        } catch (e) { console.warn('applyVisibleLocale error', e); }
    }

    function getLocale() {
        try {
            const saved = localStorage.getItem('locale');
            if (saved) return saved;
        } catch (e) {}
        try {
            const nav = (navigator.language || navigator.userLanguage || 'en').toLowerCase();
            return nav.startsWith('de') ? 'de' : 'en';
        } catch (e) { return 'en'; }
    }

    function formatTemplate(tpl, params) {
        if (!tpl) return '';
        return tpl.replace(/\{(\w+)\}/g, function(_, k) { return (params && params[k] != null) ? params[k] : ''; });
    }

    function getText(key, params) {
        const loc = getLocale();
        const set = translations[loc] || translations.en;
        const tpl = (set && set[key]) ? set[key] : (translations.en[key] || '');
        return formatTemplate(tpl, params);
    }

        async function loadPlotPositions(positionsJson = 'plot-positions.json') {
            try {
            const response = await fetch(positionsJson);
            const data = await response.json();
                plotPositions = data.plotPositions;
                mapImageData = data.referenceImage;
                console.log('Plot positions loaded successfully from', positionsJson, data);
            } catch (error) {
                console.error('Error loading plot positions from', positionsJson, error);
                // Fallback to empty array if JSON fails to load
                plotPositions = [];
            }
        }

        async function loadOverrides() {
            try {
                // Try to load from server API first. If it fails, fall back to localStorage.
                const r = await fetch('api.php?action=');
                if (!r.ok) {
                    loadOverridesFromLocal();
                    return;
                }
                const result = await r.json();
                if (result) {
                    housingOverridesByMap = (result.overrides && !Array.isArray(result.overrides)) ? result.overrides : {};
                    // Normalize interested map so arrays become object maps { plotNumber: value }
                    housingInterestedByMap = (result.interested && typeof result.interested === 'object') ? normalizeInterestedMap(result.interested) : {};
                    console.log('Loaded overrides/interested from server', housingOverridesByMap, housingInterestedByMap);
                    // Mirror to localStorage so other tabs see it
                    try { localStorage.setItem('housing_overrides_by_map', JSON.stringify(housingOverridesByMap)); } catch (e) {}
                    try { localStorage.setItem('housing_interested_by_map', JSON.stringify(housingInterestedByMap)); } catch (e) {}
                } else {
                    // fallback to localStorage
                    loadOverridesFromLocal();
                }
            } catch (err) {
                console.warn('Server API load failed, falling back to localStorage', err);
                loadOverridesFromLocal();
            }
        }

        // Normalize interested map payload: convert array values per-map into objects with string keys
        function normalizeInterestedMap(raw) {
            if (!raw || typeof raw !== 'object') return {};
            const out = {};
            Object.keys(raw).forEach(mapKey => {
                const val = raw[mapKey];
                if (Array.isArray(val)) {
                    // Convert numeric-indexed array into object keyed by plot number (string)
                    const obj = {};
                    val.forEach((v, i) => {
                        // only copy non-null/defined values
                        if (v !== null && typeof v !== 'undefined' && String(v).trim() !== '') obj[String(i)] = v;
                    });
                    out[mapKey] = obj;
                } else if (val && typeof val === 'object') {
                    out[mapKey] = val;
                } else {
                    // ignore non-object values
                    out[mapKey] = {};
                }
            });
            return out;
        }

        function loadOverridesFromLocal() {
            try {
                const raw = localStorage.getItem('housing_overrides_by_map');
                if (raw) housingOverridesByMap = JSON.parse(raw); else {
                    const old = localStorage.getItem('housing_overrides');
                    if (old) {
                        try {
                            const parsed = JSON.parse(old);
                            housingOverridesByMap = { 'alliance_map.jpg': parsed };
                            localStorage.removeItem('housing_overrides');
                        } catch (e) { housingOverridesByMap = {}; }
                    } else {
                        housingOverridesByMap = {};
                    }
                }
            } catch (e) { housingOverridesByMap = {}; }
            try {
                const rawInt = localStorage.getItem('housing_interested_by_map');
                if (rawInt) {
                    housingInterestedByMap = JSON.parse(rawInt);
                    // if it was accidentally stored as an array, coerce to object
                    if (Array.isArray(housingInterestedByMap)) housingInterestedByMap = {};
                } else housingInterestedByMap = {};
            } catch (e) { housingInterestedByMap = {}; }
            console.log('Loaded overrides/interested from localStorage', housingOverridesByMap, housingInterestedByMap);
        }

        function saveInterested() {
            // Try server save first; fallback to localStorage
            try {
                // ensure payload is an object (not an array) before sending
                const payloadInterested = Array.isArray(housingInterestedByMap) ? {} : housingInterestedByMap;
                // Mirror to localStorage right away so other tabs pick up the change
                try { localStorage.setItem('housing_interested_by_map', JSON.stringify(housingInterestedByMap)); } catch (e) {}
                fetch('api.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'save_interested', payload: payloadInterested })
                }).then(r => r.json()).then(res => {
                    console.log('save_interested server response:', res);
                    if (res && res.ok) {
                        console.log('Saved interested map data to server');
                    } else {
                        // fallback
                        localStorage.setItem('housing_interested_by_map', JSON.stringify(housingInterestedByMap));
                        console.warn('Server save_interested returned error, saved locally instead', res);
                    }
                }).catch(err => {
                    console.warn('Server save_interested failed, saving to localStorage', err);
                    try { localStorage.setItem('housing_interested_by_map', JSON.stringify(housingInterestedByMap)); } catch (e) {}
                });
            } catch (e) {
                try { localStorage.setItem('housing_interested_by_map', JSON.stringify(housingInterestedByMap)); } catch (e2) {}
            }
        }

// Debounced variant to avoid frequent saves on rapid user input
const debouncedSaveInterested = debounce(function() { saveInterested(); }, 700);

        function saveOverrides() {
            // Try server save first; fallback to localStorage
            try {
                const payloadOverrides = Array.isArray(housingOverridesByMap) ? {} : housingOverridesByMap;
                // Mirror to localStorage right away so other tabs pick up the change
                try { localStorage.setItem('housing_overrides_by_map', JSON.stringify(housingOverridesByMap)); } catch (e) {}
                fetch('api.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'save_overrides', payload: payloadOverrides })
                }).then(r => r.json()).then(res => {
                    console.log('save_overrides server response:', res);
                    if (res && res.ok) {
                        console.log('Saved overrides to server');
                    } else {
                        localStorage.setItem('housing_overrides_by_map', JSON.stringify(housingOverridesByMap));
                        console.warn('Server save_overrides returned error, saved locally instead', res);
                    }
                }).catch(err => {
                    console.warn('Server save_overrides failed, saving to localStorage', err);
                    try { localStorage.setItem('housing_overrides_by_map', JSON.stringify(housingOverridesByMap)); } catch (e) {}
                });
            } catch (e) {
                try { localStorage.setItem('housing_overrides_by_map', JSON.stringify(housingOverridesByMap)); } catch (e2) {}
            }
        }

        function getCurrentMapKey() {
            const mapBackground = document.getElementById('mapBackground');
        // Return the current map key (filename). Default to alliance_map.jpg
        const raw = (mapBackground && mapBackground.dataset && mapBackground.dataset.map) || window.selectedMapFilename || 'alliance_map.jpg';
        return normalizeMapKey(raw);
        }

        // Normalize a map key to the filename only (basename), so storage keys are consistent
        function normalizeMapKey(key) {
            if (!key) return key;
            try {
                // remove any folder prefixes
                const parts = key.split('/');
                return parts[parts.length - 1];
            } catch (e) {
                return key;
            }
        }

        function getOverridesForCurrentMap() {
            const key = getCurrentMapKey();
            return housingOverridesByMap[key] || {};
        }

        function createHousePlots() {
            const mapBackground = document.getElementById('mapBackground');
            
            // Diff-based update: reuse existing .house-plot elements when possible
            const existing = Array.from(mapBackground.querySelectorAll('.house-plot'));
            const existingByNumber = {};
            existing.forEach(n => { existingByNumber[String(n.dataset.plotNumber)] = n; });

            // Track which plotNumbers are still present
            const seen = new Set();

            plotPositions.forEach((position) => {
                // Create container for marker (so tooltip can be absolute-positioned inside)
                let plot = existingByNumber[String(position.plotNumber)];
                if (plot) {
                    // reuse
                    seen.add(String(position.plotNumber));
                } else {
                    plot = document.createElement('div');
                    plot.className = 'house-plot';
                    plot.dataset.plotNumber = position.plotNumber;
                }

                // Create an inner element for the icon so it can sit above the dot
                const iconEl = document.createElement('div');
                iconEl.className = 'house-icon';
                iconEl.style.backgroundImage = "url('icons/icon_house.png')";
                iconEl.style.backgroundSize = 'contain';
                iconEl.style.backgroundRepeat = 'no-repeat';
                iconEl.style.backgroundPosition = '50% 50%';

                // Determine owner from overrides or base data and whether there are interested names.
                const overrideName = getOverridesForCurrentMap()[position.plotNumber];
                const baseName = housingData[position.plotNumber];
                const owner = overrideName !== undefined ? overrideName : baseName;
                const currentMapKey = getCurrentMapKey();
                const interestedForMap = (housingInterestedByMap && housingInterestedByMap[currentMapKey]) ? housingInterestedByMap[currentMapKey][position.plotNumber] : '';
                // Show the green dot when the plot is owned (owner) OR when there are interested names.
                if (owner || interestedForMap) plot.classList.add('interested'); else plot.classList.remove('interested');
                // create small green dot indicator (behind the icon)
                const dot = document.createElement('div');
                dot.className = 'plot-dot';
                plot.appendChild(dot);
                // icon element appended after dot so it renders above
                plot.appendChild(iconEl);

                // Small plot number label shown next to the icon
                const lbl = document.createElement('div');
                lbl.className = 'plot-number-label';
                lbl.textContent = position.plotNumber;
                // prevent label from intercepting pointer events (clicks should hit the plot container)
                lbl.style.pointerEvents = 'none';
                // Keep the label as a child of the plot container so we can position it
                // relative to the icon and update its offset per-zoom in updatePlotPositions.
                plot.appendChild(lbl);

                

                // Hover preview: show large preview panel with image, plot number, and interested names
                plot.addEventListener('mouseenter', function() {
                    const mapKey = getCurrentMapKey();
                    const faction = /horde/i.test(mapKey) ? 'horde' : 'alliance';
                    const previewJpg = `plots/${faction}/${position.plotNumber}.jpg`;
                    const preview = document.getElementById('plotHoverPreview');
                    if (!preview) return;
                    const img = preview.querySelector('img.preview-img');
                    const numEl = preview.querySelector('.plot-number');
                    const intEl = preview.querySelector('.plot-interested');
                    img.src = previewJpg;
                    numEl.textContent = getText('plotLabel', { num: position.plotNumber });
                    // show interested names if present
                    const mapKeyCur = getCurrentMapKey();
                    const interestedForMap = (housingInterestedByMap && housingInterestedByMap[mapKeyCur]) ? housingInterestedByMap[mapKeyCur][position.plotNumber] : '';
                    intEl.textContent = interestedForMap ? (getText('interestedPrefix', { names: interestedForMap })) : '';
                    preview.style.display = 'block';
                });
                plot.addEventListener('mousemove', function(ev) {
                    const preview = document.getElementById('plotHoverPreview');
                    if (!preview) return;
                    // position near cursor but ensure it doesn't go off-screen
                    const pad = 12;
                    const previewRect = preview.getBoundingClientRect();
                    let x = ev.clientX + pad;
                    let y = ev.clientY + pad;
                    if (x + previewRect.width > window.innerWidth - 12) x = ev.clientX - previewRect.width - pad;
                    if (y + previewRect.height > window.innerHeight - 12) y = ev.clientY - previewRect.height - pad;
                    preview.style.left = x + 'px';
                    preview.style.top = y + 'px';
                });
                plot.addEventListener('mouseleave', function() {
                    const preview = document.getElementById('plotHoverPreview');
                    if (preview) preview.style.display = 'none';
                });

                // Click behavior: no modal on click (modal functionality removed)
                plot.addEventListener('click', function(e) {
                    // Intentionally left blank: modal/popup removed
                });

                // Temporarily set raw position via transform; updatePlotPositions will re-calc scaled positions
                plot.style.transform = `translate(${position.x}px, ${position.y}px)`;
                // ensure container size matches icon reference size (32x32)
                plot.style.width = '32px';
                plot.style.height = '32px';
                // prevent native touch/gesture interference on plot elements
                plot.style.touchAction = 'none';

                if (!plot.parentNode) mapBackground.appendChild(plot);
                seen.add(String(position.plotNumber));
            });

            // Remove any old plots that are no longer present
            existing.forEach(n => {
                const pnum = String(n.dataset.plotNumber);
                if (!seen.has(pnum)) n.remove();
            });
            // Cache node lists for performance
            cachedPlots = Array.from(mapBackground.querySelectorAll('.house-plot'));
            cachedIcons = Array.from(document.querySelectorAll('.house-icon'));
            cachedDots = Array.from(document.querySelectorAll('.plot-dot'));
            cachedLabels = Array.from(document.querySelectorAll('.plot-number-label'));
            // Diagnostics: expose how many plots were created
            mapBackground.dataset.plotsCreated = String(plotPositions.length || 0);
            if (window.__housingDebug) console.log('createHousePlots: created', mapBackground.dataset.plotsCreated, 'plots');
            // Build the inline editable list under the map
            buildInlinePlotList();
        }

        // Build an inline editable table under the map for quick edits
        function buildInlinePlotList() {
            const grid = document.getElementById('inlinePlotGrid');
                if (!grid) return;
                grid.innerHTML = '';
                const mapKey = getCurrentMapKey();
                const mapInterested = housingInterestedByMap[mapKey] || {};
                plotPositions.forEach(pos => {
                    const card = document.createElement('div');
                    card.className = 'plot-card';
                    const header = document.createElement('div');
                    header.className = 'plot-card-header';
                    header.textContent = getText('plotLabel', { num: pos.plotNumber });
                    const body = document.createElement('div');
                    body.className = 'plot-card-body';
                    const input = document.createElement('input');
                        input.type = 'text';
                        input.placeholder = getText('placeholderInterested');
                    input.value = mapInterested[pos.plotNumber] || '';
                    input.dataset.plotNumber = pos.plotNumber;
                    input.className = 'plot-interested-input';
                    input.addEventListener('input', function() {
                        const val = input.value.trim();
                        housingInterestedByMap[mapKey] = housingInterestedByMap[mapKey] || {};
                        if (val) {
                            housingInterestedByMap[mapKey][pos.plotNumber] = val;
                        } else {
                            delete housingInterestedByMap[mapKey][pos.plotNumber];
                        }
                        debouncedSaveInterested();
                        // update plot DOM class to reflect interested state
                        const plotEl = document.querySelector(`.house-plot[data-plot-number="${pos.plotNumber}"]`);
                        if (plotEl) {
                            if (val) plotEl.classList.add('interested'); else plotEl.classList.remove('interested');
                        }
                    });
                    body.appendChild(input);
                    card.appendChild(header);
                    card.appendChild(body);
                    grid.appendChild(card);
                });
        }

        

        // Plot editing via modal removed; use inline grid below the map for edits.

        function updatePlotPositions() {
            const mapBackground = document.getElementById('mapBackground');
            const plots = (cachedPlots && cachedPlots.length) ? cachedPlots : document.querySelectorAll('.house-plot');
            
            // Diagnostics: log invocation and count (use distinct var names to avoid redeclare)
            const diagSelectedMap = getCurrentMapKey();
            const diagMapPath = diagSelectedMap && (diagSelectedMap.startsWith('http') || diagSelectedMap.startsWith('/') || diagSelectedMap.startsWith('maps/')) ? diagSelectedMap : ('maps/' + diagSelectedMap);
            if (window.__housingDebug) console.debug('updatePlotPositions: called, plotsFound=', plots.length, 'mapPath=', diagMapPath);
            if (plots.length === 0) return;
            
            // Get the actual map image dimensions and position (same logic as grid)
            // Reuse a cached Image instance to avoid allocating many Image objects during frequent updates
            const mapImage = cachedMapImage;
            const mapPath = (getCurrentMapKey() || '').startsWith('http') || (getCurrentMapKey() || '').startsWith('/') || (getCurrentMapKey() || '').startsWith('maps/') ? getCurrentMapKey() : ('maps/' + getCurrentMapKey());
            const ensureImageLoaded = function(cb) {
                try {
                    if (cachedMapImagePath !== mapPath) {
                        cachedMapImagePath = mapPath;
                        mapImage.src = mapPath;
                    }
                } catch (e) {}
                if (mapImage.complete && mapImage.naturalWidth && mapImage.naturalHeight) {
                    // already loaded
                    try { cb(); } catch (e) {}
                } else {
                    // wait for load (attach one-time handler)
                    const onLoad = function() {
                        try { mapImage.removeEventListener('load', onLoad); } catch (e) {}
                        try { cb(); } catch (e) {}
                    };
                    mapImage.addEventListener('load', onLoad);
                }
            };
            ensureImageLoaded(function() {
                // Use layout sizes (pre-transform) so we compute positions in the wrapper's local coordinate space
                // (getBoundingClientRect() is affected by the CSS transform scale and will break calculations when zoomed)
                const containerWidth = mapBackground.clientWidth || mapBackground.offsetWidth || mapBackground.scrollWidth;
                const containerHeight = mapBackground.clientHeight || mapBackground.offsetHeight || mapBackground.scrollHeight;
                
                // Determine displayed image dimensions. If the wrapper/background already has explicit
                // pixel width/height styles (for example the initial forced 1920x1080), prefer those
                // so plot coordinates map to the visual display. Otherwise fall back to reference/native sizes.
                let imageWidth = parseFloat(mapBackground.style.width) || 0;
                let imageHeight = parseFloat(mapBackground.style.height) || 0;
                if (!imageWidth || !imageHeight) {
                    imageWidth = (mapImageData && mapImageData.width) ? mapImageData.width : mapImage.naturalWidth || mapImage.width;
                    imageHeight = (mapImageData && mapImageData.height) ? mapImageData.height : mapImage.naturalHeight || mapImage.height;
                }
                let offsetX = 0, offsetY = 0;
                // If we somehow failed to get dimensions, fall back to container containment
                if (!imageWidth || !imageHeight) {
                    const imageAspectRatio = (mapImage.width && mapImage.height) ? (mapImage.width / mapImage.height) : 1;
                    const containerAspectRatio = containerWidth / containerHeight;
                    if (imageAspectRatio > containerAspectRatio) {
                        imageWidth = containerWidth;
                        imageHeight = containerWidth / imageAspectRatio;
                        offsetX = 0;
                        offsetY = (containerHeight - imageHeight) / 2;
                    } else {
                        imageHeight = containerHeight;
                        imageWidth = containerHeight * imageAspectRatio;
                        offsetX = (containerWidth - imageWidth) / 2;
                        offsetY = 0;
                    }
                }
                
                // Ensure the wrapper and background elements match the computed displayed image size
                // so the wrapper's local coordinate system equals the visual map area.
                try {
                    const wrapperEl = document.getElementById('zoomWrapper');
                    if (wrapperEl) {
                        // set wrapper to the native image pixel size so absolute plot coordinates map directly
                        wrapperEl.style.width = imageWidth + 'px';
                        wrapperEl.style.height = imageHeight + 'px';
                    }
                    // ensure mapBackground fills the wrapper and uses exact pixel sizing
                    mapBackground.style.width = imageWidth + 'px';
                    mapBackground.style.height = imageHeight + 'px';
                    // Set background-size to exact pixel size so background pixels map 1:1 to DOM pixels
                    mapBackground.style.backgroundSize = `${imageWidth}px ${imageHeight}px`;
                    // Update debug marker overlay if present
                    // debug marker removed
                } catch (e) {
                    // ignore styling errors
                }

                // Calculate scale factor from reference image (positions JSON) to displayed image
                // Prefer reference sizes from the loaded positions JSON (mapImageData). Fall back to the actual image intrinsic size.
                const refWidth = (mapImageData && mapImageData.width) ? mapImageData.width : mapImage.width;
                const refHeight = (mapImageData && mapImageData.height) ? mapImageData.height : mapImage.height;
                const scaleX = imageWidth / refWidth;
                const scaleY = imageHeight / refHeight;
                
                // Update plot positions using the same logic as grid
                const iconWidth = 32; // icon pixel size (adjust if different)
                const iconHeight = 32;

                // Determine if this is the Horde map by filename or reference data
                const mapKey = getCurrentMapKey() || '';
                const isHorde = /horde/i.test(mapKey) || (mapImage && /horde/i.test(mapImage.src));

                // Build a lookup from plotNumber to original position so DOM order doesn't matter
                const posByNumber = {};
                plotPositions.forEach(p => { posByNumber[p.plotNumber] = p; });
                if (window.__housingDebug) console.debug('updatePlotPositions: mapKey=', mapKey, 'isHorde=', isHorde, 'mapImage.width/height=', mapImage.width, mapImage.height, 'imageWidth/height=', imageWidth, imageHeight, 'offsetX/Y=', offsetX, offsetY, 'scaleX/Y=', scaleX, scaleY, 'referenceImage=', mapImageData);

                // mapSizeDisplay element removed; no-op

                plots.forEach((plot) => {
                    const plotNum = Number(plot.dataset.plotNumber);
                    const originalPos = posByNumber[plotNum];
                    if (originalPos) {
                        // Compute scaled X from reference coords
                        const scaledX = offsetX + (originalPos.x * scaleX);
                        // For Horde map some coordinate systems were inverted; compute both candidates and pick the one inside the displayed image
                        const refHeight = (mapImageData && mapImageData.height) ? mapImageData.height : mapImage.height;
                        const yCandidateNormal = offsetY + (originalPos.y * scaleY);
                        const yCandidateInverted = offsetY + ((refHeight - originalPos.y) * scaleY);

                        // Choose which Y makes more sense: prefer inverted for Horde, but fall back to normal if out-of-bounds
                        let chosenScaledY = yCandidateNormal;
                        const inBounds = (v) => (v >= (offsetY - 2) && v <= (offsetY + imageHeight + 2));
                        if (isHorde) {
                            if (inBounds(yCandidateInverted)) chosenScaledY = yCandidateInverted;
                            else if (inBounds(yCandidateNormal)) chosenScaledY = yCandidateNormal;
                        } else {
                            if (inBounds(yCandidateNormal)) chosenScaledY = yCandidateNormal;
                            else if (inBounds(yCandidateInverted)) chosenScaledY = yCandidateInverted;
                        }

                        const scaledY = chosenScaledY;

                        // per-plot scaling computed

                        // Center the icon by subtracting half the icon size.
                        // All coordinates are computed in pre-transform (local) coordinates, so do NOT divide by currentZoom here.
                        const finalLeft = (scaledX - (iconWidth / 2));
                        const finalTop = (scaledY - (iconHeight / 2));
                        // Use transform translate for GPU-accelerated movement
                        plot.style.transform = `translate(${finalLeft}px, ${finalTop}px)`;

                        // nothing debug-related here

                        // Adjust label position so it moves closer to the icon when zooming in,
                        // while keeping its visual size constant.
                        try {
                            const lblEl = plot.querySelector('.plot-number-label');
                            if (lblEl) {
                                // inverse scale for visual constancy
                                const invScale = (currentZoom && isFinite(currentZoom)) ? (1 / currentZoom) : 1;
                                // base horizontal offset in px at zoom = 1
                                const baseOffsetX = 12;
                                // reduce offset when zooming in so label approaches the icon
                                const offsetX = baseOffsetX / (currentZoom || 1);
                                // keep vertical centering via -50% and apply inverse scale
                                lblEl.style.transform = `translate(${offsetX}px, -50%) scale(${invScale})`;
                                lblEl.style.transformOrigin = 'left center';
                            }
                        } catch (e) {}
                    }
                });
                // After resizing wrapper/background and repositioning plots, ensure view is clamped/centered
                try {
                    // Do not reset translate/zoom here; keep currentTranslate/currentZoom so panning persists.
                    clampTranslate();
                    applyTransform(0);
                } catch (e) { try { clampTranslate(); applyTransform(0); } catch (ex) {} }
            });
        }

    // --- Zoom support ---
    let currentZoom = 1.0;
        // track translate offsets (pre-scale coordinates)
        let currentTranslateX = 0;
        let currentTranslateY = 0;
    // Allow free panning (map can be moved regardless of bounds)
    let allowFreePan = true;
    let initialPanApplied = false;
    // animation handle for fling/inertia
    let flingAnimation = null;
// Auto-fit state: whether we've applied the automatic fit-to-screen yet
let autoFitDone = false;
// Initial display size on page load (requested)
const INITIAL_DISPLAY_WIDTH = 1920;
const INITIAL_DISPLAY_HEIGHT = 1080;
// Fraction of container to occupy with the map (0..1). 0.7 = 70% of available viewport.
const VIEWPORT_FRACTION = 0.7;
    // Track discrete zoom steps: after 2 steps, next zoom resets to 100%
    let zoomStepCounter = 0;
        const MIN_ZOOM = 0.25;
        const MAX_ZOOM = 3.0;
                // Apply transform with translate + scale (transform-origin fixed at 0 0)
                function applyTransform(transitionMs = 220) {
                    const wrapper = document.getElementById('zoomWrapper');
                    if (!wrapper) return;
                    if (window.__housingDebug) console.debug('applyTransform', { zoom: currentZoom, tx: currentTranslateX, ty: currentTranslateY, transitionMs });
                    if (transitionMs && transitionMs > 0) wrapper.style.transition = `transform ${transitionMs}ms ease`;
                    else wrapper.style.transition = '';
                    wrapper.style.transformOrigin = '0 0';
                    // Apply current translate and zoom so the map can be panned freely inside the container
                    wrapper.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px) scale(${currentZoom})`;
                    const resetBtn = document.getElementById('zoomResetBtn');
                    if (resetBtn) resetBtn.textContent = Math.round(currentZoom * 100) + '%';
                    // Update positions after transform (coalesced via RAF)
                    setTimeout(() => scheduleUpdatePlotPositions(), transitionMs ? Math.max(25, transitionMs - 20) : 25);
                    // Ensure icons/dots use base sizes (no zoom scaling)
                    try {
                        // Use cached node lists when available
                        const icons = (cachedIcons && cachedIcons.length) ? cachedIcons : document.querySelectorAll('.house-icon');
                        const dots = (cachedDots && cachedDots.length) ? cachedDots : document.querySelectorAll('.plot-dot');
                        const labels = (cachedLabels && cachedLabels.length) ? cachedLabels : document.querySelectorAll('.plot-number-label');
                        // Inverse-scale icons/dots so they remain visually constant while the wrapper scales
                        const invScale = (currentZoom && isFinite(currentZoom)) ? (1 / currentZoom) : 1;
                        // Set CSS variables on the wrapper so children can pick them up without iterating all nodes
                        try {
                            const wrapper = document.getElementById('zoomWrapper');
                            if (wrapper) {
                                wrapper.style.setProperty('--icon-scale', String(invScale));
                                wrapper.style.setProperty('--label-scale', String(invScale));
                                wrapper.style.setProperty('--dot-scale', String(invScale));
                            }
                        } catch (e) {}
                        // Still ensure dot size/width are set (cheap writes)
                        dots.forEach(d => {
                            d.style.width = '14px';
                            d.style.height = '14px';
                        });
                    } catch (e) {}
                    // minimap removed
                }

                function setZoom(newZoom, centerClientX = null, centerClientY = null, animate = true) {
                    // Clamp
                    const z = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, Number(newZoom) || 1));
                    // If a center is provided, perform a centered zoom so the point under cursor stays fixed
                    if (centerClientX !== null && centerClientY !== null) {
                        zoomAtPoint(centerClientX, centerClientY, z / currentZoom, !animate);
                        return;
                    }
                    currentZoom = z;
                    // keep translate valid
                    clampTranslate();
                    applyTransform(animate ? 220 : 0);
                }

                // Zoom about a client (screen) point by a factor (zoomFactor = newZoom/oldZoom)
                function zoomAtPoint(clientX, clientY, zoomFactor, instant = false) {
                    if (!isFinite(zoomFactor) || zoomFactor <= 0) return;
                    const mapInner = document.querySelector('.map-inner');
                    const wrapper = document.getElementById('zoomWrapper');
                    if (!mapInner || !wrapper) return;
                    const oldZoom = currentZoom;
                    let newZoom = oldZoom * zoomFactor;
                    newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
                    // If zoom didn't change, nothing to do
                    if (Math.abs(newZoom - oldZoom) < 1e-6) return;

                    // Compute adjustment so the point under cursor stays stationary.
                    const mapRect = mapInner.getBoundingClientRect();
                    // formula: tx' = tx + (clientX - mapRect.left) * (1/newZoom - 1/oldZoom)
                    const deltaFactor = (1 / newZoom) - (1 / oldZoom);
                    currentTranslateX = currentTranslateX + (clientX - mapRect.left) * deltaFactor;
                    currentTranslateY = currentTranslateY + (clientY - mapRect.top) * deltaFactor;

                    currentZoom = newZoom;
                    clampTranslate();
                    applyTransform(instant ? 0 : 160);
                }

                function zoomIn() { setZoom(Math.min(MAX_ZOOM, currentZoom * 1.2), null, null, true); }
                function zoomOut() { setZoom(Math.max(MIN_ZOOM, currentZoom / 1.2), null, null, true); }
                function resetZoom() { currentZoom = 1.0; currentTranslateX = 0; currentTranslateY = 0; applyTransform(160); }

                // Clamp translate so the scaled wrapper always covers the container (no empty gaps)
                function clampTranslate() {
                    try {
                        if (typeof allowFreePan !== 'undefined' && allowFreePan) {
                            // Free panning enabled: do not clamp translate to container bounds
                            // but keep values within a large safe range
                            if (!Number.isFinite(currentTranslateX)) currentTranslateX = 0;
                            if (!Number.isFinite(currentTranslateY)) currentTranslateY = 0;
                            currentTranslateX = Math.max(-100000, Math.min(100000, currentTranslateX));
                            currentTranslateY = Math.max(-100000, Math.min(100000, currentTranslateY));
                            return;
                        }
                        const wrapper = document.getElementById('zoomWrapper');
                        const container = document.querySelector('.map-container');
                        if (!wrapper || !container) return;
                        const W = wrapper.offsetWidth || wrapper.clientWidth || 0; // pre-transform width
                        const H = wrapper.offsetHeight || wrapper.clientHeight || 0;
                        const A = container.clientWidth || 0; // container visible area
                        const B = container.clientHeight || 0;
                        const Z = Number(currentZoom) || 1;
                        if (W <= 0 || H <= 0 || A <= 0 || B <= 0) return;

                        // layoutLeft/layoutTop = position of the wrapper's top-left inside the container before transform
                        const layoutLeft = (A - W) / 2;
                        const layoutTop = (B - H) / 2;

                        // When scaled width <= container, center the scaled element
                        if (Z * W <= A) {
                            // desired finalLeft = (A - Z*W)/2
                            currentTranslateX = (W * (1 - Z)) / (2 * Z);
                        } else {
                            // Constraints derived so that finalLeft = layoutLeft + Z*tx stays within [A - Z*W, 0]
                            const minTX = ((A + W) / 2 - Z * W) / Z; // ((A+W)/2 - ZW)/Z
                            const maxTX = -((A - W) / 2) / Z; // -(A-W)/(2Z)
                            if (!Number.isFinite(minTX) || !Number.isFinite(maxTX)) {
                                currentTranslateX = Math.max(-10000, Math.min(10000, currentTranslateX));
                            } else {
                                currentTranslateX = Math.min(maxTX, Math.max(minTX, currentTranslateX));
                            }
                        }

                        if (Z * H <= B) {
                            currentTranslateY = (H * (1 - Z)) / (2 * Z);
                        } else {
                            const minTY = ((B + H) / 2 - Z * H) / Z;
                            const maxTY = -((B - H) / 2) / Z;
                            if (!Number.isFinite(minTY) || !Number.isFinite(maxTY)) {
                                currentTranslateY = Math.max(-10000, Math.min(10000, currentTranslateY));
                            } else {
                                currentTranslateY = Math.min(maxTY, Math.max(minTY, currentTranslateY));
                            }
                        }

                        // final sanity guard
                        if (!Number.isFinite(currentTranslateX)) currentTranslateX = 0;
                        if (!Number.isFinite(currentTranslateY)) currentTranslateY = 0;
                    } catch (e) { console.warn('clampTranslate error', e); }
                }

        // Helper to initialize UI with selected map
        function applySelectedMap(mapFilename) {
            const mapBackground = document.getElementById('mapBackground');
            // set as dataset so other scripts can read it
            mapBackground.dataset.map = mapFilename;
            // set CSS background-image to chosen file
            const cssPath = (mapFilename.startsWith('http') || mapFilename.startsWith('/') || mapFilename.startsWith('maps/')) ? mapFilename : ('maps/' + mapFilename);
            mapBackground.style.backgroundImage = `url('${cssPath}')`;
            // expose globally for legacy code
            window.selectedMapFilename = mapFilename;
            // minimap removed
        }

        async function initWithMap(mapFilename) {
            applySelectedMap(mapFilename);

            // reset initial pan flag so first update can center if desired
            initialPanApplied = false;

            // Choose positions JSON based on mapFilename
            let positionsFile = 'plot-positions.json';
            if (/horde/i.test(mapFilename)) {
                positionsFile = 'horde-plot-positions.json';
            } else if (/alliance/i.test(mapFilename)) {
                // if there is an explicit alliance positions file, prefer it
                positionsFile = 'alliance-plot-positions.json';
            }

            // Load plot positions from JSON file first
            await loadPlotPositions(positionsFile);

            // Create house plots after positions are loaded
            createHousePlots();

            // Force initial display to requested resolution (1920x1080) on first load
            try {
                const wrapperEl = document.getElementById('zoomWrapper');
                const mapBackground = document.getElementById('mapBackground');
                if (wrapperEl && mapBackground && !autoFitDone) {
                    wrapperEl.style.width = INITIAL_DISPLAY_WIDTH + 'px';
                    wrapperEl.style.height = INITIAL_DISPLAY_HEIGHT + 'px';
                    mapBackground.style.width = INITIAL_DISPLAY_WIDTH + 'px';
                    mapBackground.style.height = INITIAL_DISPLAY_HEIGHT + 'px';
                    mapBackground.style.backgroundSize = `${INITIAL_DISPLAY_WIDTH}px ${INITIAL_DISPLAY_HEIGHT}px`;
                    // mark that we applied the initial sizing so updatePlotPositions uses the displayed size
                    autoFitDone = true;
                }
            } catch (e) {}

            // Update positions on window resize
            let plotResizeTimeout;
                window.addEventListener('resize', function() {
                // Clear existing timeout to prevent multiple rapid calls
                clearTimeout(plotResizeTimeout);
                // Schedule update via RAF for smoother handling
                plotResizeTimeout = setTimeout(() => scheduleUpdatePlotPositions(), 80);
            });

            // Initial position update
            setTimeout(updatePlotPositions, 100);

            // Create initial grid overlay when pressing G (grid-overlay.js handles keypress)
        }

        // Realtime sync: polling + storage listener will keep data in sync across tabs/users
        function showMapSelectionModal() {
            // removed: modal-based map chooser was removed; initialization uses saved choice or default
            return;
        }

        function hideMapSelectionModal() {
            // no-op for compatibility with older calls
            return;
        }

        document.addEventListener('DOMContentLoaded', async function() {
            // If user previously chose a map, use it. Otherwise use default
            let saved = localStorage.getItem('wow_map_choice');
            if (saved) saved = normalizeMapKey(saved);
            // Load overrides first, then init map so initial data is available
            await loadOverrides();
            const startMap = saved || 'alliance_map.jpg';
            await initWithMap(startMap);
            // Ensure any zoom/translate state is reset on page load so the map is static
            currentZoom = 1.0;
            currentTranslateX = 0;
            currentTranslateY = 0;
            autoFitDone = false; // reset auto-fit so the map can be auto-fitted again if desired
            applyTransform(0);
            // Start real-time sync to pick up changes from other users or tabs
            startRealtimeSync();

            // Wire change-map button in legend (if present)
            const changeBtn = document.getElementById('changeMapBtn');
            if (changeBtn) {
                changeBtn.addEventListener('click', function() {
                    showMapSelectionModal();
                });
            }

            // Apply translations for visible UI elements (legend, buttons, inline header)
            try {
                const inlineHeader = document.getElementById('inlinePlotHeader');
                if (inlineHeader) inlineHeader.textContent = getText('inlinePlotHeader');
                const legendTitle = document.querySelector('.legend .legend-title');
                if (legendTitle) legendTitle.textContent = getText('legendTitle') || legendTitle.textContent;
                // legend availability labels (first two items' span)
                const legendSpans = document.querySelectorAll('.legend .legend-item > span');
                if (legendSpans && legendSpans.length >= 2) {
                    legendSpans[0].textContent = getText('availableLabel') || legendSpans[0].textContent;
                    legendSpans[1].textContent = getText('interestedLabel') || legendSpans[1].textContent;
                }
                const chooseAllianceLegendBtn = document.getElementById('chooseAllianceLegend');
                if (chooseAllianceLegendBtn) chooseAllianceLegendBtn.textContent = getText('chooseAlliance') || chooseAllianceLegendBtn.textContent;
                const chooseHordeLegendBtn = document.getElementById('chooseHordeLegend');
                if (chooseHordeLegendBtn) chooseHordeLegendBtn.textContent = getText('chooseHorde') || chooseHordeLegendBtn.textContent;
                const toggleBtn = document.getElementById('togglePlotNumbersBtn');
                if (toggleBtn) toggleBtn.textContent = getText('plotToggle') || toggleBtn.textContent;
                const zoomBtn = document.getElementById('zoomResetBtn');
                if (zoomBtn) zoomBtn.textContent = getText('zoomReset') || zoomBtn.textContent;
            } catch (e) {}

            // Locale flag buttons wiring
            try {
                const btnEn = document.getElementById('localeBtnEn');
                const btnDe = document.getElementById('localeBtnDe');
                function setActiveLocaleButton(locale) {
                    if (btnEn) btnEn.classList.toggle('active', locale === 'en');
                    if (btnDe) btnDe.classList.toggle('active', locale === 'de');
                }
                const curLocale = getLocale();
                setActiveLocaleButton(curLocale);
                if (btnEn) btnEn.addEventListener('click', function(e) { applyVisibleLocale('en'); setActiveLocaleButton('en'); });
                if (btnDe) btnDe.addEventListener('click', function(e) { applyVisibleLocale('de'); setActiveLocaleButton('de'); });
            } catch (e) {}
            // Ensure UI reflects current locale on load
            try { applyVisibleLocale(getLocale()); } catch (e) {}

            // Zoom via mouse wheel only when the pointer is over the mapBackground (prevents accidental page zoom)

            // Legend direct map buttons
            const chooseAllianceLegend = document.getElementById('chooseAllianceLegend');
            const chooseHordeLegend = document.getElementById('chooseHordeLegend');
            if (chooseAllianceLegend) chooseAllianceLegend.addEventListener('click', function(e) {
                const remember = e.shiftKey === true;
                chooseMap('alliance_map.jpg', remember);
            });
            if (chooseHordeLegend) chooseHordeLegend.addEventListener('click', function(e) {
                const remember = e.shiftKey === true;
                chooseMap('horde_map.jpg', remember);
            });

            // Plot number toggle in legend
            const togglePlotNumbersBtn = document.getElementById('togglePlotNumbersBtn');
            function applyPlotNumberVisibility(show) {
                const labels = document.querySelectorAll('.plot-number-label');
                labels.forEach(l => { if (show) l.classList.remove('hidden'); else l.classList.add('hidden'); });
                if (togglePlotNumbersBtn) {
                    if (show) togglePlotNumbersBtn.classList.add('active'); else togglePlotNumbersBtn.classList.remove('active');
                }
            }
            // Read persisted preference (default: show)
            let showPlotNumbers = true;
            try { const raw = localStorage.getItem('show_plot_numbers'); if (raw !== null) showPlotNumbers = raw === '1' || raw === 'true'; } catch (e) {}
            applyPlotNumberVisibility(showPlotNumbers);
            if (togglePlotNumbersBtn) togglePlotNumbersBtn.addEventListener('click', function() {
                showPlotNumbers = !showPlotNumbers;
                try { localStorage.setItem('show_plot_numbers', showPlotNumbers ? '1' : '0'); } catch (e) {}
                applyPlotNumberVisibility(showPlotNumbers);
            });

            // Zoom reset button
            const zoomResetBtn = document.getElementById('zoomResetBtn');
            if (zoomResetBtn) zoomResetBtn.addEventListener('click', function() { resetZoom(); });

            // Re-enable interactive pan (drag) inside the page container: allow pointer-drag to translate the zoomWrapper
            const wrapperEl = document.getElementById('zoomWrapper');
            const bgEl = document.getElementById('mapBackground');
            const mapInnerEl = document.querySelector('.map-inner');
            if (wrapperEl && bgEl && mapInnerEl) {
                // Pointer-based panning (drag) enabled: capture pointer on down and track movement
                let isPanning = false;
                let lastX = 0, lastY = 0;
                let movedWhilePanning = false;

                mapInnerEl.addEventListener('pointerdown', function onDown(e) {
                    if (e.button !== 0) return; // left only
                    isPanning = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    movedWhilePanning = false;
                    try { mapInnerEl.setPointerCapture(e.pointerId); } catch (ex) {}
                    // stop any ongoing fling
                    stopFling();
                }, { passive: false });

                window.addEventListener('pointermove', function onMove(e) {
                    if (!isPanning) return;
                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;
                    // if significant movement occurred mark as a drag
                    if (Math.abs(dx) > 4 || Math.abs(dy) > 4) movedWhilePanning = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    // update translate in px
                    currentTranslateX += dx;
                    currentTranslateY += dy;
                    // Do not clamp strictly to container bounds so content can overflow visually
                    // but keep a soft clamp to avoid runaway values
                    clampTranslate();
                    applyTransform(0);
                }, { passive: true });

                window.addEventListener('pointerup', function onUp(e) {
                    if (!isPanning) return;
                    isPanning = false;
                    try { mapInnerEl.releasePointerCapture(e.pointerId); } catch (ex) {}
                    // If the pointer didn't move significantly, treat this as a click (not a pan)
                    try {
                        if (!movedWhilePanning) {
                            // Determine the plot element under the pointer robustly
                            let plotEl = null;
                            try { plotEl = e.target && e.target.closest ? e.target.closest('.house-plot') : null; } catch (ex) { plotEl = null; }
                            // Fallback: elementFromPoint at the pointer position
                            if (!plotEl) {
                                try {
                                    const el = document.elementFromPoint(e.clientX, e.clientY);
                                    plotEl = el && el.closest ? el.closest('.house-plot') : null;
                                } catch (ex) { plotEl = null; }
                            }
                            if (plotEl) {
                                const plotNum = plotEl.dataset && plotEl.dataset.plotNumber ? plotEl.dataset.plotNumber : null;
                                if (plotNum) {
                                    const mapKey = getCurrentMapKey();
                                    const faction = /horde/i.test(mapKey) ? 'horde' : 'alliance';
                                    // visual feedback
                                    try {
                                        plotEl.classList.add('clicked-feedback');
                                        setTimeout(() => plotEl.classList.remove('clicked-feedback'), 300);
                                    } catch (e) {}
                                    // Open the modal for this plot
                                    openPlotModal(plotNum, faction);
                                }
                            }
                        }
                    } catch (err) {}

                                        // Additional capturing click listener as a robust fallback for clicks on markers
                                        // Click-capture fallback removed: no modal opened on clicks
                });

                window.addEventListener('pointercancel', function onCancel(e) {
                    if (!isPanning) return;
                    isPanning = false;
                    try { mapInnerEl.releasePointerCapture(e.pointerId); } catch (ex) {}
                });
                // Wheel-to-zoom: when the mouse wheel is used over the visible map area, zoom centered on pointer
                    mapInnerEl.addEventListener('wheel', function (ev) {
                    // Only act when the pointer is over the map and the event is not from a touchpad two-finger scroll
                    // Prevent page scroll while zooming
                    ev.preventDefault();
                    const delta = ev.deltaY || ev.wheelDelta || -ev.detail;
                    // Normalize wheel direction: positive delta -> zoom out, negative -> zoom in
                    const zoomFactor = delta > 0 ? 0.92 : 1.08;
                    zoomAtPoint(ev.clientX, ev.clientY, zoomFactor, false);
                    }, { passive: false });
            }

            // Fling / inertia
            function startFling(vx, vy) {
                stopFling();
                const decay = 0.95; // per frame multiplier
                const frame = () => {
                    // apply velocity in client px -> translate units (divide by zoom)
                    currentTranslateX += (vx * 16) / currentZoom;
                    currentTranslateY += (vy * 16) / currentZoom;
                    clampTranslate();
                    applyTransform(0);
                    // decay
                    vx *= decay;
                    vy *= decay;
                    if (Math.abs(vx) < 0.01 && Math.abs(vy) < 0.01) {
                        stopFling();
                        return;
                    }
                    flingAnimation = requestAnimationFrame(frame);
                };
                flingAnimation = requestAnimationFrame(frame);
            }
            function stopFling() {
                if (flingAnimation) { cancelAnimationFrame(flingAnimation); flingAnimation = null; }
            }

            // minimap removed

                // Keyboard panning removed per request


            // On-screen pan buttons removed

            // Edit plots modal removed; edits are done inline below the map

                // Modal close wiring for plot image modal
                    const plotModal = document.getElementById('plotImageModal');
                    const plotModalClose = document.getElementById('plotImageClose');
                    const plotPrevBtn = document.getElementById('plotPrevBtn');
                    const plotNextBtn = document.getElementById('plotNextBtn');
                    if (plotModalClose) plotModalClose.addEventListener('click', function() { if (plotModal) plotModal.style.display = 'none'; });
                    if (plotModal) plotModal.addEventListener('click', function(e) {
                        if (e.target === plotModal) plotModal.style.display = 'none';
                    });
                    if (plotPrevBtn) plotPrevBtn.addEventListener('click', function(ev) { ev.stopPropagation(); navigatePlot(-1); });
                    if (plotNextBtn) plotNextBtn.addEventListener('click', function(ev) { ev.stopPropagation(); navigatePlot(1); });

                    // Keyboard navigation: left/right arrows to navigate, Esc to close
                    window.addEventListener('keydown', function(ev) {
                        try {
                            if (!plotModal || plotModal.style.display === 'none') return;
                            if (ev.key === 'ArrowLeft') { ev.preventDefault(); navigatePlot(-1); }
                            else if (ev.key === 'ArrowRight') { ev.preventDefault(); navigatePlot(1); }
                            else if (ev.key === 'Escape') { ev.preventDefault(); plotModal.style.display = 'none'; }
                        } catch (e) {}
                    });
        });

        // Debug functions removed

            // debug marker references/listeners removed

        // Handlers for modal buttons (delegated)
            // Helper to open the plot image modal consistently
            // Navigation state for modal
            let currentPlotIndex = -1;

            function openPlotByIndex(index) {
                if (!Array.isArray(plotPositions) || plotPositions.length === 0) return;
                // Wrap around
                const len = plotPositions.length;
                let idx = index;
                if (idx < 0) idx = (idx % len + len) % len;
                if (idx >= len) idx = idx % len;
                currentPlotIndex = idx;
                const pos = plotPositions[currentPlotIndex];
                if (!pos) return;
                const mapKey = getCurrentMapKey();
                const faction = /horde/i.test(mapKey) ? 'horde' : 'alliance';
                try {
                    const modal = document.getElementById('plotImageModal');
                    const modalImg = document.getElementById('plotImageModalImg');
                    const caption = document.getElementById('plotImageCaption');
                    const interestedEl = document.getElementById('plotImageInterested');
                    if (!modal || !modalImg) return;
                    const imgSrc = `plots/${faction}/${pos.plotNumber}.jpg`;
                    modalImg.src = imgSrc;
                    if (caption) caption.textContent = getText('plotLabel', { num: pos.plotNumber }) + ` (${faction})`;
                    // Show interested names for the current map if present
                    try {
                        const interestedForMap = (housingInterestedByMap && housingInterestedByMap[mapKey]) ? housingInterestedByMap[mapKey][pos.plotNumber] : '';
                        if (interestedEl) interestedEl.textContent = interestedForMap ? (getText('interestedPrefix', { names: interestedForMap })) : '';
                    } catch (e) { if (interestedEl) interestedEl.textContent = ''; }
                    modal.style.display = 'flex';
                    // preload neighbors for faster navigation
                    try {
                        const prevIdx = (currentPlotIndex - 1 + len) % len;
                        const nextIdx = (currentPlotIndex + 1) % len;
                        const prevSrc = `plots/${faction}/${plotPositions[prevIdx].plotNumber}.jpg`;
                        const nextSrc = `plots/${faction}/${plotPositions[nextIdx].plotNumber}.jpg`;
                        const pi = new Image(); pi.src = prevSrc;
                        const ni = new Image(); ni.src = nextSrc;
                    } catch (e) {}
                } catch (e) { console.warn('openPlotByIndex error', e); }
            }

            function navigatePlot(delta) {
                if (!Array.isArray(plotPositions) || plotPositions.length === 0) return;
                const next = (currentPlotIndex === -1) ? 0 : (currentPlotIndex + delta);
                openPlotByIndex(next);
            }

            function openPlotModal(plotNumber, faction) {
                try {
                    // Find index for plotNumber in plotPositions
                    const idx = plotPositions.findIndex(p => String(p.plotNumber) === String(plotNumber));
                    if (idx !== -1) {
                        openPlotByIndex(idx);
                    } else {
                        // fallback: just build a temporary position object and show
                        const modal = document.getElementById('plotImageModal');
                        const modalImg = document.getElementById('plotImageModalImg');
                        const caption = document.getElementById('plotImageCaption');
                        const interestedEl = document.getElementById('plotImageInterested');
                        if (!modal || !modalImg) return;
                        const imgSrc = `plots/${faction}/${plotNumber}.jpg`;
                        modalImg.src = imgSrc;
                        if (caption) caption.textContent = getText('plotLabel', { num: plotNumber }) + ` (${faction})`;
                        if (interestedEl) interestedEl.textContent = '';
                        modal.style.display = 'flex';
                    }
                } catch (e) { console.warn('openPlotModal error', e); }
            }

        function chooseMap(mapFilename, remember) {
            initWithMap(mapFilename);
            if (remember) localStorage.setItem('wow_map_choice', normalizeMapKey(mapFilename));
            hideMapSelectionModal();
        }

        // ---- Real-time sync utilities ----
        // Compare two objects shallowly for differences (used to avoid unnecessary redraws)
        // Stable stringify that sorts object keys so comparisons are deterministic
        function stableStringify(obj) {
            const seen = new WeakSet();
            function sorter(a, b) { return a < b ? -1 : (a > b ? 1 : 0); }
            function _replacer(value) {
                if (value && typeof value === 'object') {
                    if (seen.has(value)) return null; // break cycles
                    seen.add(value);
                    if (Array.isArray(value)) return value.map(_replacer);
                    const keys = Object.keys(value).sort(sorter);
                    const out = {};
                    keys.forEach(k => { out[k] = _replacer(value[k]); });
                    return out;
                }
                return value;
            }
            try {
                return JSON.stringify(_replacer(obj));
            } catch (e) {
                try { return JSON.stringify(obj); } catch (e2) { return String(obj); }
            }
        }

        function shallowDifferent(a, b) {
            try {
                return stableStringify(a) !== stableStringify(b);
            } catch (e) { return true; }
        }

        // Apply server-provided data if it's different from current, then refresh UI
        function applyServerDataIfChanged(serverData) {
            if (!serverData) return;
            const sOverrides = (serverData.overrides && !Array.isArray(serverData.overrides)) ? serverData.overrides : {};
            const sInterested = normalizeInterestedMap(serverData.interested || {});
            // If top-level objects differ, replace and refresh
            if (shallowDifferent(housingOverridesByMap, sOverrides)) {
                housingOverridesByMap = sOverrides;
                console.log('Realtime: overrides updated, refreshing UI');
                // Recreate plots to apply new occupancy data
                createHousePlots();
                scheduleUpdatePlotPositions();
            }
            if (shallowDifferent(housingInterestedByMap, sInterested)) {
                housingInterestedByMap = sInterested;
                console.log('Realtime: interested updated, refreshing UI');
                // update inline grid values
                buildInlinePlotList();
                // Apply interested class only for plots on the currently displayed map.
                const curKey = getCurrentMapKey();
                const curMapData = (housingInterestedByMap && housingInterestedByMap[curKey]) ? housingInterestedByMap[curKey] : {};
                // For each plot element, toggle the 'interested' class based on current map data
                const plotEls = (cachedPlots && cachedPlots.length) ? cachedPlots : document.querySelectorAll('.house-plot');
                plotEls.forEach(el => {
                    const pnum = String(el.dataset.plotNumber);
                    if (curMapData && Object.prototype.hasOwnProperty.call(curMapData, pnum) && curMapData[pnum]) {
                        el.classList.add('interested');
                    } else {
                        el.classList.remove('interested');
                    }
                });
            }
        }

        // Poll the server for the latest overrides/interested and apply if changed
        let realtimePollTimer = null;
        async function pollForServerUpdates() {
            try {
                const r = await fetch('api.php?action=');
                if (!r.ok) return;
                const data = await r.json();
                // Only apply and mirror into localStorage when data actually differs
                const newOverrides = (data && data.overrides && !Array.isArray(data.overrides)) ? data.overrides : {};
                const newInterested = normalizeInterestedMap(data && data.interested ? data.interested : {});
                const overridesJson = JSON.stringify(newOverrides);
                const interestedJson = JSON.stringify(newInterested);

                // Apply to UI only when different from the in-memory copy
                const overridesChanged = shallowDifferent(housingOverridesByMap, newOverrides);
                const interestedChanged = shallowDifferent(housingInterestedByMap, newInterested);
                if (overridesChanged || interestedChanged) {
                    applyServerDataIfChanged({ overrides: newOverrides, interested: newInterested });
                }

                // Mirror into localStorage for other tabs only when the stored string differs
                try {
                    const storedOverrides = localStorage.getItem('housing_overrides_by_map') || '{}';
                    if (storedOverrides !== overridesJson) localStorage.setItem('housing_overrides_by_map', overridesJson);
                } catch (e) {}
                try {
                    const storedInterested = localStorage.getItem('housing_interested_by_map') || '{}';
                    if (storedInterested !== interestedJson) localStorage.setItem('housing_interested_by_map', interestedJson);
                } catch (e) {}
            } catch (e) {
                // ignore network failures here; we'll keep trying
                //console.warn('Realtime poll failed', e);
            }
        }

        function startRealtimeSync(intervalMs = 6000) {
            // Start short polling loop
            if (realtimePollTimer) clearInterval(realtimePollTimer);
            // Do an immediate fetch then schedule (only if polling enabled)
            try { if (typeof pollingEnabled === 'undefined' || pollingEnabled) pollForServerUpdates(); } catch (e) {}
            realtimePollTimer = setInterval(() => { if (typeof pollingEnabled === 'undefined' || pollingEnabled) pollForServerUpdates(); }, intervalMs);

            // Listen for localStorage changes (other tabs) and apply them immediately
            window.addEventListener('storage', function(e) {
                try {
                    if (e.key === 'housing_overrides_by_map') {
                        const val = e.newValue ? JSON.parse(e.newValue) : {};
                        applyServerDataIfChanged({ overrides: val, interested: housingInterestedByMap });
                    } else if (e.key === 'housing_interested_by_map') {
                        const val = e.newValue ? JSON.parse(e.newValue) : {};
                        applyServerDataIfChanged({ overrides: housingOverridesByMap, interested: val });
                    } else if (e.key === 'wow_map_choice') {
                        // map choice changed in another tab — switch map immediately
                        const newMap = e.newValue ? normalizeMapKey(e.newValue) : null;
                        if (newMap) {
                            console.log('Realtime: map choice changed in another tab, switching to', newMap);
                            initWithMap(newMap);
                        }
                    }
                } catch (ex) { console.warn('Realtime storage handler error', ex); }
            });
            // Page Visibility: pause polling when the tab is hidden to save resources
            if (typeof document !== 'undefined' && 'visibilityState' in document) {
                window.addEventListener('visibilitychange', function() {
                    try {
                        if (document.hidden) {
                            window.pollingEnabled = false;
                            console.log('Polling paused (tab hidden)');
                        } else {
                            window.pollingEnabled = true;
                            console.log('Polling resumed (tab visible)');
                            // immediate fetch on resume
                            pollForServerUpdates();
                        }
                    } catch (e) {}
                });
            }
        }

        
    </script>
    <!-- map chooser removed; initialization uses saved map or default -->
        <!-- Plot edit modal removed; use inline grid for edits -->
    <script src="grid-overlay.js"></script>
    
    <!-- Plot image modal -->
    <div id="plotImageModal" class="plot-image-modal" style="display:none;">
        <div class="plot-image-card">
            <button id="plotImageClose" class="plot-image-close">✕</button>
            <div style="text-align:center; position:relative;">
                <button id="plotPrevBtn" class="plot-nav-btn" title="Previous" style="position:absolute; left:8px; top:50%; transform:translateY(-50%); z-index:20;">◀</button>
                <img id="plotImageModalImg" src="" alt="Plot preview" style="max-width:90vw; max-height:80vh; border-radius:6px; box-shadow:0 8px 32px rgba(0,0,0,0.6); background:#111;" />
                <button id="plotNextBtn" class="plot-nav-btn" title="Next" style="position:absolute; right:8px; top:50%; transform:translateY(-50%); z-index:20;">▶</button>
            </div>
            <div id="plotImageCaption" style="margin-top:8px; text-align:center; color:#ddd; font-size:13px;"></div>
            <div id="plotImageInterested" style="margin-top:6px; text-align:center; color:#bcd; font-size:12px;"></div>
        </div>
    </div>
</body>
</html>
